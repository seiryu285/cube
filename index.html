<!DOCTYPE html>
<html lang="ja">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>洗練された明るいインタラクティブ3D立方体彫刻</title>
    <style>
        body, html {
            margin: 0;
            padding: 0;
            width: 100%;
            height: 100%;
            overflow: hidden;
            background-color: #1a1a2e;
        }
        canvas {
            display: block;
        }
    </style>
</head>
<body>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/gsap/3.9.1/gsap.min.js"></script>
    <script id="vertexShader" type="x-shader/x-vertex">
        attribute float size;
        attribute vec3 customColor;
        varying vec3 vColor;
        uniform float time;
        uniform vec3 mousePosition;
        
        void main() {
            vColor = customColor;
            vec3 pos = position;
            
            float dist = distance(pos, mousePosition);
            float effect = smoothstep(7.0, 0.0, dist);
            pos += normalize(pos - mousePosition) * effect * 3.0;
            
            vec4 mvPosition = modelViewMatrix * vec4(pos, 1.0);
            gl_PointSize = size * (30.0 / -mvPosition.z) * (1.0 + sin(time + pos.x * 0.25) * 0.5);
            gl_Position = projectionMatrix * mvPosition;
        }
    </script>
    <script id="fragmentShader" type="x-shader/x-fragment">
        varying vec3 vColor;
        
        void main() {
            if (length(gl_PointCoord - vec2(0.5, 0.5)) > 0.475) discard;
            gl_FragColor = vec4(vColor, 1.0);
        }
    </script>
    <script>
        let scene, camera, renderer, cube, particles;
        let raycaster, mouse;
        let segments = [];

        init();
        animate();

        function init() {
            scene = new THREE.Scene();
            camera = new THREE.PerspectiveCamera(75, window.innerWidth / window.innerHeight, 0.1, 1000);
            camera.position.z = 30;

            renderer = new THREE.WebGLRenderer({ antialias: true });
            renderer.setSize(window.innerWidth, window.innerHeight);
            renderer.setPixelRatio(window.devicePixelRatio);
            document.body.appendChild(renderer.domElement);

            // 立方体の作成
            const size = 10;
            const segmentSize = 0.5;
            const segmentsPerSide = Math.floor(size / segmentSize);

            const geometry = new THREE.BoxGeometry(segmentSize, segmentSize, segmentSize);
            const material = new THREE.MeshPhysicalMaterial({
                color: 0xffffff,
                metalness: 0.2,
                roughness: 0.1,
                clearcoat: 1.0,
                clearcoatRoughness: 0.1,
                reflectivity: 1.0,
                emissive: 0x111111
            });

            cube = new THREE.InstancedMesh(geometry, material, Math.pow(segmentsPerSide, 3));
            cube.instanceMatrix.setUsage(THREE.DynamicDrawUsage);

            let index = 0;
            for (let x = 0; x < segmentsPerSide; x++) {
                for (let y = 0; y < segmentsPerSide; y++) {
                    for (let z = 0; z < segmentsPerSide; z++) {
                        const position = new THREE.Vector3(
                            (x - segmentsPerSide / 2 + 0.5) * segmentSize,
                            (y - segmentsPerSide / 2 + 0.5) * segmentSize,
                            (z - segmentsPerSide / 2 + 0.5) * segmentSize
                        );
                        const quaternion = new THREE.Quaternion();
                        const scale = new THREE.Vector3(1, 1, 1);
                        const matrix = new THREE.Matrix4();
                        matrix.compose(position, quaternion, scale);
                        cube.setMatrixAt(index, matrix);

                        segments.push({
                            index: index,
                            position: position,
                            originalPosition: position.clone(),
                            currentScale: scale.clone()
                        });

                        index++;
                    }
                }
            }

            scene.add(cube);

            // パーティクルシステムの作成
            const particlesGeometry = new THREE.BufferGeometry();
            const particleCount = 5000;
            const positions = new Float32Array(particleCount * 3);
            const colors = new Float32Array(particleCount * 3);
            const sizes = new Float32Array(particleCount);

            for (let i = 0; i < particleCount; i++) {
                positions[i * 3] = (Math.random() - 0.5) * 20;
                positions[i * 3 + 1] = (Math.random() - 0.5) * 20;
                positions[i * 3 + 2] = (Math.random() - 0.5) * 20;
                colors[i * 3] = 0.8 + Math.random() * 0.2;
                colors[i * 3 + 1] = 0.8 + Math.random() * 0.2;
                colors[i * 3 + 2] = 0.8 + Math.random() * 0.2;
                sizes[i] = Math.random() * 0.05 + 0.02;
            }

            particlesGeometry.setAttribute('position', new THREE.BufferAttribute(positions, 3));
            particlesGeometry.setAttribute('customColor', new THREE.BufferAttribute(colors, 3));
            particlesGeometry.setAttribute('size', new THREE.BufferAttribute(sizes, 1));

            const particlesMaterial = new THREE.ShaderMaterial({
                uniforms: {
                    time: { value: 0 },
                    mousePosition: { value: new THREE.Vector3() }
                },
                vertexShader: document.getElementById('vertexShader').textContent,
                fragmentShader: document.getElementById('fragmentShader').textContent,
                transparent: true,
                blending: THREE.AdditiveBlending,
                depthWrite: false
            });

            particles = new THREE.Points(particlesGeometry, particlesMaterial);
            scene.add(particles);

            // ライティング
            const ambientLight = new THREE.AmbientLight(0x404040);
            scene.add(ambientLight);

            const directionalLight = new THREE.DirectionalLight(0xffffff, 0.5);
            directionalLight.position.set(1, 1, 1);
            scene.add(directionalLight);

            const pointLight = new THREE.PointLight(0xffffff, 1, 100);
            pointLight.position.set(0, 0, 10);
            scene.add(pointLight);

            raycaster = new THREE.Raycaster();
            mouse = new THREE.Vector2();

            document.addEventListener('mousemove', onDocumentMouseMove, false);
            window.addEventListener('resize', onWindowResize, false);
        }

        function onDocumentMouseMove(event) {
            event.preventDefault();
            mouse.x = (event.clientX / window.innerWidth) * 2 - 1;
            mouse.y = -(event.clientY / window.innerHeight) * 2 + 1;
        }

        function onWindowResize() {
            camera.aspect = window.innerWidth / window.innerHeight;
            camera.updateProjectionMatrix();
            renderer.setSize(window.innerWidth, window.innerHeight);
        }

        function animate() {
            requestAnimationFrame(animate);
            render();
        }

        function render() {
            const time = performance.now() * 0.001;
            particles.material.uniforms.time.value = time;

            raycaster.setFromCamera(mouse, camera);
            const intersects = raycaster.intersectObject(cube);

            if (intersects.length > 0) {
                const intersectionPoint = intersects[0].point;
                particles.material.uniforms.mousePosition.value.copy(intersectionPoint);
            }

            segments.forEach(segment => {
                let targetPosition = segment.originalPosition.clone();
                let targetScale = new THREE.Vector3(1, 1, 1);
                let targetColor = new THREE.Color(0xffffff);

                if (intersects.length > 0) {
                    const intersectionPoint = intersects[0].point;
                    const distance = segment.position.distanceTo(intersectionPoint);
                    const maxDistance = 7;
                    if (distance < maxDistance) {
                        const factor = 1 - distance / maxDistance;
                        const direction = segment.position.clone().sub(intersectionPoint).normalize();
                        targetPosition.add(direction.multiplyScalar(factor * 3));
                        targetScale.setScalar(1 + factor * 0.5);
                        targetColor.setHSL(0.6, factor, 0.8 + factor * 0.2);
                    }
                }

                gsap.to(segment.position, {
                    x: targetPosition.x,
                    y: targetPosition.y,
                    z: targetPosition.z,
                    duration: 0.3
                });

                gsap.to(segment.currentScale, {
                    x: targetScale.x,
                    y: targetScale.y,
                    z: targetScale.z,
                    duration: 0.3
                });

                const matrix = new THREE.Matrix4();
                matrix.compose(segment.position, new THREE.Quaternion(), segment.currentScale);
                cube.setMatrixAt(segment.index, matrix);

                cube.setColorAt(segment.index, targetColor);
            });

            cube.instanceMatrix.needsUpdate = true;
            cube.instanceColor.needsUpdate = true;

            cube.rotation.x += 0.001;
            cube.rotation.y += 0.002;

            particles.rotation.x = cube.rotation.x;
            particles.rotation.y = cube.rotation.y;

            renderer.render(scene, camera);
        }
    </script>
</body>
</html>